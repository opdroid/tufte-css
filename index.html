<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Journal</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>

  <body>
    <article>
      <h1 id="tufte-css">An extremely mundane journal</h1>
      <p class="subtitle">Deepankar Sharma</p>
      <section>
        <p>Processing the world slowly at ~60 Hz</p>
      </section>
      
      <section>
        <h2 id="blog">Blog</h2>
        
        		<h3 id="basis">Basis</h3>
		<p>
		    Basis: the underlying support or foundation for an idea,
		    argument, or process.
		</p>
		<p>
		    This notion shows up all over the place in all kinds of
		    systems. In people this shows up as fundamental traits on
		    which the rest of the personality rests.
		    In math it shows as axioms and fundamental theorems.
		    In computer systems this shows up in a less defined way
		    than in math, but if you squint hard enough you can see the
		    same idea in play in any system of moderate or higher
		    complexity (ie a set of core primitives or mental model).
		</p>
		<p>
		    If we buy into the idea that a system is specified by a
		    collection of basis which we call its bases (plural of basis)
		    then here are some thoughts about them
		</p>
		<ul>
		    <li>The bases should be orthogonal, ie the definition of one basis must not depend on another</li>
		    <li>Each basis should be an easily understood property of the system</li>
		    <li>The bases uniquely identify a system to a degree that systems with the same bases are intellectually almost identical</li>
		    <li>A basis that is poorly implemented or hard to use in a given system effectively stops being a basis in practice since few users come to rely on it</li>
		    <li>A problem can be effectively solved in a system if it can be decomposed effectively in terms of the bases of the system </li>
		    <li>If you change a basis in a system you get a completely new system</li>
		    <li>If you remove a basis from a system it must immediately come crashing to the ground, completely unable to fulfill any of its objectives. If this is not true then what you removed is not a basis</li>
		    <li>Basis should be added to a system with extreme reluctance. As a rule of thumb the utility of a system needs to grow exponentially with every added basis. This keeps the complexity of the system in check</li>
		    <li>If you are looking to make non trivial changes to a system (aka a paradigm shift) and are leaving the existing bases intact then you are fooling yourself</li>
		    <li>If you dont consciously think or decide on the bases of a system, bases will be selected for you by nature in the form of quirks and side effects of the implementation</li>
		    <li>If you are in the business of building/improving/maintaining systems you need to watch every change/progress in the world from the lens of the bases of your systems. How does this change affect the bases?
			Does it invalidate any assumptions in one or more of the bases? Does it change the tradeoffs such that a different set of bases might be more favorable? Do the bases need to be upgraded / restated? Is it time to dump
			the bases and pick new bases to build a new system?</li>
		    <li>A useful thought exercise is to go over your bases one at a time and ask what systems would result if the opposite of this basis was in effect? Ie what happens if you contradict this basis. If you have been
			paying attention you would know why it is safe to do this one basis at a time</li>
		    <li>Once you start dealing in bases, working on things where you do not have the freedom or ability to change the bases feels incredibly limiting</li>
		    <li>As the weight of things built on top of the system increases over the years it becomes increasingly difficult to change the bases. One needs to accept this reality and mark a system done at some point and move on</li>
		    <li>Do not become loyal or fascinated with a particular bases or system. Loyalty should be towards the act of evaluating bases and examining the systems that result from them</li>
		</ul>
        
        <h3>Code for tool makers<h3>
           <ol>
             <li>Think of your users as being smarter than you</li>
             <li>Breaking your tool into a minimal number of orthogonal concepts is key</li>
             <li>A good tool should commoditize the toolmaker. An ideal tool should render the toolmaker as jobless.</li>
             <li>Much thought needs to go into the boundary between the tool and the user. I hesitate to use the word interface here even though its meaning is apt since it has a very specific meaning in computing. The boundary needs to be clearly demarcated and should be stable in the order of years if not decades. Specifically the boundary should survive complete reimplementations of the tool</li>
             <li>A tool that helps a person earn their paycheck should be learnable in a couple of weeks. Smaller less ambitious tools should use that as an upperbound and scale downwards from there to require an amount of learning in proportion to the value they add to the users life</li>
          </ol>
          
        
        <h3>Hello World!</h3>
        <p>Starting to strip the anonymity away bit by bit. </p>
      </section>
    </article>
  </body>
</html>
